<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="/dist/reset.css" />
    <link rel="stylesheet" href="/dist/reveal.css" />
    <link rel="stylesheet" href="/dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="/plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Abusing the type system</h1>
          <h3>for fun and for profit</h3>
        </section>

        <section>
          <section>
            <h2>Conrad Ludgate</h2>
            <aside class="notes">Talk about who you are</aside>
          </section>

          <section>
            <img src="rust-community.png"/><br/>
            https://discord.com/invite/rust-lang-community
            <aside class="notes">Moderator of</aside>
          </section>

          <section>
            <img src="first-rust-commit.png"/><br/>
            <aside class="notes">Writing Rust for over 5 years</aside>
          </section>

          <section>
            <img src="neon.svg" width="500"/><br/>
            <h3>Serverless Postgres</h3>
            <h4><a href="https://neon.tech">https://neon.tech/</a></h4>
            <aside class="notes">Talk about postgres and stuff</aside>
          </section>
        </section>

        <section>
          <section>
            Raise your hands...
          </section>
          <section data-auto-animate>
            <p data-id="question0">Raise your hands if you have</p>
            <p data-id="question1">never written any Rust?</p>
          </section>
          <section data-auto-animate>
            <p data-id="question0">Raise your hands if you have</p>
            <p data-id="question1">written a little bit of Rust?</p>
          </section>
          <section data-auto-animate>
            <p data-id="question0">Raise your hands if you have</p>
            <p data-id="question1">used Rust for a few months?</p>
          </section>
          <section data-auto-animate>
            <p data-id="question0">Raise your hands if you have</p>
            <p data-id="question1">used Rust for roughly a year?</p>
          </section>
        </section>

        <section>
          <section>Why do we like Rust?</section>
          <section>
            <blockquote>
              Modern APIs, high-level features, and C-speed
            </blockquote>
          </section>
          <section>
            <blockquote>
              [memory] safety by default, generally not a pain to write
            </blockquote>
          </section>
          <section>
            <blockquote>It makes my friends think Iâ€™m smart</blockquote>
          </section>
          <section>
            ...
            <aside class="notes">Ask the audience</aside>
          </section>
          <section>
            If it compiles, it works!

            <aside class="notes">
              This isn't true, but these sayings don't come from nowhere.
              Writing Rust in clever ways can eliminate so called "trivial bugs"
            </aside>
          </section>
        </section>

        <section>
          <section>
            I have to confess...<br />
            We had a bug at Neon

            <aside class="notes">
              IMPORTANT: it wasn't severe because of security practices we have in place,
              but you could imagine that this would be a bad bug in other scenarios
            </aside>
          </section>
          <section data-transition="none-out slide-in">
            <img src="proxy-simple.png" />
          </section>
          <section data-transition="none-in slide-out">
            <img src="proxy-cplane-cache.png" />
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              let key = creds.endpoint().expect("impossible");

              if let Some(cached) = self.caches.node_info.get(key) {
                  info!(key, "found cached compute node info");
                  return Ok(cached);
              }

              let node = self.do_wake_compute(extra, creds).await?;
              let (_, cached) = self.caches.node_info.insert(key, node);
              info!(key, "created a cache entry for compute node info");

              Ok(cached)
            </code></pre>
            <aside class="notes">Old code</aside>
          </section>

          <section>
            <img src="pitr.png" />
            <img src="pitr-query-headers.png" />
            <aside class="notes">
              We started development of our point-in-time-restore feature which meant now that the endpoint is no longer sufficient to identifiy a specific postgres instance
              (don't worry, the password was revoked already)
            </aside>
          </section>

          <section>
            <table>
              <tr>
                <td>username</td>
                <td>conrad</td>
              </tr>
              <tr>
                <td>endpoint</td>
                <td>br-wispy-mode-73730913</td>
              </tr>
              <tr>
                <td>options</td>
                <td>neon_timestamp:2024-03-23T11:00:00.000Z</td>
              </tr>
            </table>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers="1">
              let key = creds.endpoint().expect("impossible");

              if let Some(cached) = self.caches.node_info.get(key) {
                  info!(key, "found cached compute node info");
                  return Ok(cached);
              }
            </code></pre>
            <aside class="notes">Old code</aside>
          </section>
          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers="1">
              let key: &str = &creds.cache_key;

              if let Some(cached) = self.caches.node_info.get(key) {
                  info!(key, "found cached compute node info");
                  return Ok(cached);
              }
            </code></pre>
            <aside class="notes">New code, uses pre-calculated cache key</aside>
          </section>
          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust">
              let cache_key = format!(
                  "{}{}",
                  endpoint.as_deref().unwrap_or_default(),
                  neon_options(params).as_deref().unwrap_or_default(),
              );
            </code></pre>
            <aside class="notes">How the cache key is computed</aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust">
              // Password hack should set the endpoint name.
              // TODO: make `creds.endpoint` more type-safe.
              assert!(creds.endpoint.is_some());
            </code></pre>
            <aside class="notes">This is a load bearing comment</aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust">
              let cache_key = format!("");
            </code></pre>
            <aside class="notes">
              Sometimes the cache key is effectively this
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              pub struct ComputeUserInfo {
                  pub endpoint: Option&LeftAngleBracket;SmolStr&RightAngleBracket;,
                  pub user: SmolStr,
                  pub cache_key: SmolStr,
              }
            </code></pre>
            <aside class="notes">
              Old code
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              pub struct ComputeUserInfo {
                  pub endpoint: SmolStr,
                  pub inner: ComputeUserInfoNoEndpoint,
              }

              pub struct ComputeUserInfoMaybeEndpoint {
                  pub endpoint: Option&LeftAngleBracket;SmolStr&RightAngleBracket;,
                  pub inner: ComputeUserInfoNoEndpoint,
              }

              pub struct ComputeUserInfoNoEndpoint {
                  pub user: SmolStr,
                  pub cache_key: SmolStr,
              }
            </code></pre>
            <aside class="notes">New code, now with more separation</aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              pub struct ComputeUserInfoNoEndpoint {
                  pub user: SmolStr,
                  pub options: NeonOptions,
              }

              pub struct NeonOptions(Vec<(SmolStr, SmolStr)>);

              impl ComputeUserInfo {
                  pub fn endpoint_cache_key(&self) -> SmolStr {
                      self.inner.options.get_cache_key(&self.endpoint)
                  }
              }
            </code></pre>
            <aside class="notes">The actual bug fix</aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              pub struct EndpointCacheKey(SmolStr);

              impl ComputeUserInfo {
                  pub fn endpoint_cache_key(&self) -> EndpointCacheKey {
                      EndpointCacheKey(self.inner.options.get_cache_key(&self.endpoint))
                  }
              }
            </code></pre>
            <aside class="notes">
              How to prevent this happening in the future. EndpointCacheKey can
              only be constructed by this function, on a ComputeUserInfo struct
              that must have an endpoint set.
            </aside>
          </section>

          <section>
            <h2>Key findings</h2>
            <p class="fragment fade-up" data-fragment-index="1">
              <span class="fragment semi-fade-out" data-fragment-index="2"
                >Options are not your friends.</span
              >
            </p>
            <p class="fragment fade-up" data-fragment-index="2">
              Use the newtype pattern.
            </p>
            <aside class="notes">
              Don't use option if the value is not optional.

              Use the newtype pattern to restrict creation of important values to safe places only
            </aside>
          </section>
        </section>

        <section>
          <section>
            Case study 2: rustls</br>
            <img src="rustls-logo.png" width="300" />

            <aside class="notes">
              Rustls is a TLS implementation written in 100% safe rust.
              It has a runtime configurable cryptographic library, supporting _ring_ and AWS libcrypto among others
            </aside>
          </section>

          <section>
            bugs in rustls are catastropic...

            <aside class="notes">
              Given that rustls is memory safe, no heartbleed can happen, however
              a bug in rustls could still skip certificate verification,
              or skip intergrity and authenticity checks...
              that is bad as a mitm can exploit that.
            </aside>
          </section>

          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-c" data-line-numbers>
              if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
                  goto fail;
              if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
                  goto fail;
                  goto fail;
              if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
                  goto fail;

              err = sslRawVerify(..);
            </code></pre>

            <aside class="notes">
              Ask the class if they recognise this bug from 2014 in apple's SSL implementation,
              if not, see if they can spot the exact line where the bug is caused.
            </aside>
          </section>
          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-c" data-line-numbers="5">
              if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
                  goto fail;
              if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
                  goto fail;
                  goto fail;
              if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
                  goto fail;

              err = sslRawVerify(..);
            </code></pre>
            <aside class="notes">
              This is an unconditional jump.
            </aside>
          </section>
          <section data-auto-animate>
            <pre
              data-id="code-animation"
            ><code data-trim data-noescape type="text/template" class="language-c" data-line-numbers="9">
              if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
              {
                  goto fail;
              }
              if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
              {
                  goto fail;
              }
                  goto fail;
              if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
              {
                  goto fail;
              }

              err = sslRawVerify(..);
            </code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-c" data-line-numbers>
              fail:
                SSLFreeBuffer(&signedHashes);
                SSLFreeBuffer(&hashCtx);
                return err;
            </code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-c" data-line-numbers>
              if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
              {
                  goto free_and_return;
              }
              if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
              {
                  goto free_and_return;
              }
              goto free_and_return; // err == 0. successful verification.
              if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
              {
                  goto free_and_return;
              }
            </code></pre>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              SSLHashSHA1.update(&mut hashCtx, &serverRandom)?;
              SSLHashSHA1.update(&mut hashCtx, &signedParams)?;
              return Ok(());
              SSLHashSHA1.final(&hashCtx, &mut hashOut)?;

              sslRawVerify(..)?;
            </code></pre>
            <aside class="notes">
              rewritten in rust, the buggy line is immediately obvious, but this misses the point.
              skipping validation of the server certificate is still 1 line away.
            </aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers="9,10">
              struct ExpectFinished {
                  config: Arc<ClientConfig>,
                  server_name: ServerName<'static>,
                  randoms: ConnectionRandoms,
                  suite: &'static Tls13CipherSuite,
                  transcript: HandshakeHash,
                  key_schedule: KeyScheduleHandshake,
                  client_auth: Option<ClientAuthDetails>,
                  cert_verified: verify::ServerCertVerified,
                  sig_verified: verify::HandshakeSignatureValid,
              }
            </code></pre>
            <aside class="notes">
              A finished handshake from a client's perspective.
            </aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              let cert_verified = self.config.verifier.verify_server_cert(
                  end_entity,
                  intermediates,
                  &self.server_name,
                  &self.server_cert.ocsp_response,
                  now,
              )?;
            </code></pre>
            <aside class="notes">
              A finished handshake from a client's perspective.
            </aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
              let sig_verified = self.config.verifier.verify_tls13_signature(
                  &construct_server_verify_message(&handshake_hash),
                  end_entity,
                  cert_verify,
              )?;
            </code></pre>
            <aside class="notes">
              A finished handshake from a client's perspective.
            </aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template" class="language-rust" data-line-numbers>
                impl ServerCertVerifier for WebPkiServerVerifier {
                    fn verify_server_cert(&self, ...) -> Result<ServerCertVerified, Error> {
                        verify_server_cert_signed_by_trust_anchor_impl(
                            &cert,
                            &self.roots
                        )?;
                        verify_server_name(&cert, server_name)?;
                        Ok(ServerCertVerified::assertion())
                    }
                }
            </code></pre>
            <aside class="notes">
              A finished handshake from a client's perspective.
            </aside>
          </section>

          <section>
            <pre><code data-trim data-noescape type="text/template">
              $ rg "ServerCertVerified::assertion()" rustls/src -C 2
              rustls/src/client/tls13.rs
              429-            // We *don't* reverify the certificate chain here: resumption is a
              430-            // continuation of the previous session in terms of security policy.
              431:            let cert_verified = verify::ServerCertVerified::assertion();
              432-            let sig_verified = verify::HandshakeSignatureValid::assertion();
              433-            Ok(Box::new(ExpectFinished {

              rustls/src/client/tls12.rs
              139-                            .into_owned(),
              140-                    );
              141:                    let cert_verified = verify::ServerCertVerified::assertion();
              142-                    let sig_verified = verify::HandshakeSignatureValid::assertion();
              143-

              rustls/src/verify.rs
              353-    );
              354-    assert_eq!(
              355:        format!("{:?}", ServerCertVerified::assertion()),
              356-        "ServerCertVerified(())"
              357-    );

              rustls/src/webpki/server_verifier.rs
              255-
              256-        verify_server_name(&cert, server_name)?;
              257:        Ok(ServerCertVerified::assertion())
              258-    }
              259-
            </code></pre>
          </section>
          <section>
            <p>state machines</p>
            <img src="tls-state-1.svg" width="200"/>
          </section>
        </section>
      </div>
    </div>

    <script src="/dist/reveal.js"></script>
    <script src="/plugin/notes/notes.js"></script>
    <script src="/plugin/highlight/highlight.js"></script>
    <script src="/plugin/zoom/zoom.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealHighlight, RevealNotes, RevealZoom],
      });
    </script>
  </body>
</html>
